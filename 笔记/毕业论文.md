intro
related research
lsepi
method
step1-n （implementation）
project management
evaluation
conclusion
refer

在本章中，我们将讨论项目的实现细节。首先我会介绍我所使用的开发环境，编程语言，接下来，我会介绍网络的超参数设定以及训练细节。我们还会介绍我为了项目演示所开发的网站。

对于硬件环境，本项目使用一台NVIDIA 4090D服务器开发。对于软件环境，我使用了Ubuntu 22.04 LTS操作系统。我使用了Python开发了本项目，具体来说，深度学习部分，我使用了Pytorch来实现。对于展示网页部分，我使用了FastAPI作为后端，并采用Vue作为前端。

项目整体主要分为数据预处理，模型构建，训练，推理测试这几个几个阶段。

在本章中，我将以开发环境，数据预处理，模型构建与训练，推理，展示的过程介绍实现的细节。

对于开发环境，我使用了一台安装有NVIDIA 4090D的服务器进行开发，系统未Ubuntu 22.04 LTS。项目主体部分采用Python开发，具体来说，深度学习部分采用了Pytorch来实现，而在网页展示部分，我是用FastAPI作为后端框架，Vue作为前端框架。

对于数据预处理，我使用了cheng等人推荐的数据预处理方法。具体来说，若数据提供了面部关键点坐标以及相机坐标（训练时），我们将几何中心点作为剪裁中心点，然后裁剪边长为关键点间距1.5倍的正方形作为面部区域。面部区域被缩放为256x256。之后，为了消除人距离相机以及旋转带来的几何差异，我们根据相机坐标构建旋转矩阵与缩放矩阵，使虚拟摄像机永远正对面部中心，并固定距离，得到标准化图像。若数据没有提供面部关键点坐标以及相机坐标（推理时），我们将通过Google提供的mediapipe机器学习库来确定面部关键点坐标得到剪裁中心点，并通过固定双眼距离为面部图像的0.72倍来近似得到标准化图像。

对于模型构建与训练，我们在EVE数据集以及EYEDIAP数据集上都进行了训练。对于超参数的设置如下：

对于推理过程，我们首先使用OBS软件来录制人的视频，并使用上述的数据预处理方法得到用户的面部crop。之后调用已训练好的模型对视频进行推理。为确保使用合理的显存，我们将视频分为多个长度为250帧的片段进行分布推理。得到每一帧的注视方向后，我们使用OpenCV提供的arrow工具在图上标出注视方向vector在图像平面的二维投影，并重新组合成视频输出，得到可视化效果。

对于网页展示部分，我使用了FastAPI作为后端，Vue作为前端，并遵循了前后端分离的结构以及RESTful API的设计搭建网站。所有数据的可视化都通过前端模块ECharts完成。



```
.
├── README.md
├── model
│   └── rtdnet.py
├── train.py
├── eval_eve.py
├── eval_eyediap.py
├── infer_for_normal.py
├── api
│   ├── dist
│   └── main.py
├── core
│   ├── __init__.py
│   ├── config_default.py
│   └── training.py
├── datasources
│   ├── __init__.py
│   ├── common.py
│   ├── eyediap_sequences.py
│   └── eve_sequences.py
├── requirements.txt
├── saving
│   └── rtdnet_8_4096.pth
├── utils
│   ├── __init__.py
│   ├── loss.py
│   ├── util_functions.py
│   └── wandb_setup.py
└── wandb
```
好的，我准备多提到以下内容： 显卡具体信息 开发环境依赖库版本号，放到appendix 给出项目结构，并通过如model.py（模型定义，其中有TDModule等模块的定义），train.py（训练脚本）介绍我写的一些重要代码文件，如dataloader 数据预处理代码 日志管理，超参数配置方法，断点训练方法 可视化用了wandb epochs，batch_size, 并提到在实验阶段会提到训练集和验证集的分割方式 本章更多是介绍代码实现与系统部署的细节；有关网络结构、模块设计与损失函数的原理性说明，详见第 X 章（Methodology）。” 你认为加上这些信息是否足够？

好的，我准备多提到以下内容：
显卡具体信息
开发环境依赖库版本号，放到appendix
给出项目结构，并通过如model.py（模型定义，其中有TDModule等模块的定义），train.py（训练脚本）介绍我写的一些重要代码文件，如dataloader
数据预处理代码
日志管理，超参数配置方法，断点训练方法
可视化用了wandb
epochs，batch_size, 并提到在实验阶段会提到训练集和验证集的分割方式
本章更多是介绍代码实现与系统部署的细节；有关网络结构、模块设计与损失函数的原理性说明，详见第 X 章（Methodology）。”

你认为加上这些信息是否足够？

把We改改
相关工作可以加点旧工作
上传gitlab代码


在本章中，我将首先介绍gaze estimation的发展情况和相关文献，之后，我将阐释我从这些文献中得到的项目启发。

考虑到video-based gaze estimation领域方法的空缺，我尝试提出新的方法来使estimation result更精准。首先，根据Section 2.2中提到的，CNN和ViT都可作为模型的backbone。考虑到计算资源的限制以及训练难度，我将选择CNN作为backbone。另外，以面部图像为输入普遍优于其他输入，所以我也将采用面部为输入。在上下文利用的方面，过去的方法普遍使用RNN。为了更好地利用上下文，我将尝试在模型的多个位置加入显式设计利用上下文信息。对于CNN backbone，我将改动结构从而使其能够捕捉运动信息，丰富上下文。对于序列处理部分，除了尝试RNN，我也讲尝试被广泛证明有效的Transformer。另外，对于损失函数，我也将一个序列轨迹作为单位进行计算，从而利用上下文信息。
对于数据集，本领域可用的数据集只有EVE和EYEDIAP dataset，所以我将在这两个数据集上做实验。

未来的工作可以在以下两点展开。第一，设计更有效的运动信息捕捉与结合的方法，从而更好地利用上下文信息增强视频的gaze estimation结果。第二，制作新的video-based gaze estimation数据集，这一领域仍然缺乏数据集。

```
\section{Limitations in Existing Previous Methods}

Despite the demonstrated benefits of leveraging temporal information in video-based gaze estimation, several challenges remain. First, existing recurrent approaches (\eg, LSTM, GRU) strongly rely on continuous and relatively stable video frames. Sudden frame drops, significant head rotations, or partial occlusions (such as a hand briefly covering one eye) can break the learned temporal context and degrade performance. Second, although methods like Gaze360~\cite{kellnhofer2019gaze360} and others have shown improvements over static counterparts, they still face limitations in handling \emph{fast} or \emph{large-amplitude} head poses, as short-term motion cues alone may not capture all pose variations. Third, these temporal models often incur higher computational cost---each frame requires CNN feature extraction, followed by an additional sequence-processing step. This hinders deployment on resource-limited devices such as mobile phones or AR headsets, especially when longer video clips are used to improve accuracy. Lastly, most public gaze datasets, including EVE~\cite{park2020towards} and EYEDIAP~\cite{funes2014eyediap}, while valuable, may not fully represent real-world complexities like diverse backgrounds, severe lighting changes, or rapid head movements.

These limitations highlight the need for a method that more explicitly captures subtle inter-frame motion while also fusing global temporal context across multiple levels of feature representation. In the next chapter, I introduce \textbf{RTDNet}, a novel approach designed to address these issues by integrating a Temporal Difference Module (TDModule) to extract motion features, a multi-level recurrent structure to iteratively fuse them with spatial features, and a sequence-level loss (PDA Loss) that aligns entire gaze trajectories over time. This design aims to overcome the aforementioned challenges and further improve the precision and robustness of video-based gaze estimation.

```
```
\section{现有先前方法中的限制}

尽管在基于视频的凝视估计中利用时间信息已经表现出了一些好处，但仍然存在一些挑战。首先，现有的循环方法（如LSTM、GRU）严重依赖连续且相对稳定的视频帧。突然的帧丢失、显著的头部旋转或部分遮挡（例如手短暂遮挡一个眼睛）可能会破坏学习到的时间上下文并降低性能。其次，尽管像Gaze360~\cite{kellnhofer2019gaze360}等方法相对于静态对应物有所改进，但它们仍然在处理\emph{快速}或\emph{大幅度}头部姿势时存在局限，因为仅凭短期运动线索可能无法捕捉所有姿势变化。第三，这些时间模型通常会带来更高的计算成本---每帧都需要进行CNN特征提取，然后再进行额外的序列处理步骤。这会阻碍在资源有限的设备上部署，例如移动电话或AR头戴设备，尤其是在使用更长的视频剪辑以提高准确性时。最后，大多数公共凝视数据集，包括EVE~\cite{park2020towards}和EYEDIAP~\cite{funes2014eyediap}，虽然有价值，但可能无法完全代表真实世界的复杂性，如多样化的背景、严重的光照变化或快速的头部运动。

这些限制凸显了需要一种更明确地捕捉微妙的帧间运动的方法，同时还要融合多个特征表示级别上的全局时间上下文。在下一章中，我介绍\textbf{RTDNet}，这是一种新颖的方法，旨在通过集成一个时间差异模块（TDModule）来提取运动特征，一个多级循环结构来迭代地将其与空间特征融合，以及一个序列级损失（PDA Loss），以随时间对齐整个凝视轨迹。这一设计旨在克服上述挑战，进一步提高基于视频的凝视估计的精度和鲁棒性。
```
```
\section{Limitations in Existing Previous Methods}

Although many studies have attempted to leverage temporal cues for video-based gaze estimation, there remain several limitations that we aim to address in this work:

\begin{enumerate}[label=\textbf{L\arabic*:}, leftmargin=1.2cm]
    \item \textbf{Inter-frame motion is not explicitly modeled.}
    Most existing methods rely on stacking frames into RNNs (e.g., LSTM, GRU), focusing on high-level temporal dependencies but overlooking \emph{fine-grained} inter-frame changes. These subtle movements (like small eye shifts or partial facial motions) can significantly impact accuracy, yet are not captured by standard recurrent designs.

    \item \textbf{Insufficient multi-level feature fusion.}
    Recurrent or 3D-convolution-based approaches typically merge spatial and temporal features at a single stage. Shallow layers may capture small details but lack global context, while deeper layers collect broader context but miss fine movement cues. This trade-off often results in suboptimal performance when large pose changes or more nuanced eye movements occur.

    \item \textbf{Trajectory-level alignment is overlooked.}
    Most methods compute frame-wise losses (e.g., $\ell_2$ or angular loss) independently, thereby ignoring the shape and continuity of the entire gaze trajectory. Even if consecutive frames are correctly predicted, slight frame-by-frame offsets can accumulate into a misaligned or non-smooth trajectory across time.

    \item \textbf{Capturing both short-term and long-term dependencies is challenging.}
    RNN-based approaches handle sequences sequentially, which can limit efficiency and the capacity to learn long-range interactions. While some works adopt bidirectional schemes or deeper LSTM stacks, handling extended video clips or rapidly shifting gaze remains difficult, especially under real-world conditions like head rotations or partial occlusions.
\end{enumerate}

\vspace{0.5em}\noindent
\textbf{Correspondingly, this thesis proposes RTDNet, a Recurrent Network using Temporal Difference, to address these issues:}

\begin{itemize}[leftmargin=1.2cm]
    \item \textbf{TDModule for explicit inter-frame motion} (addresses L1). 
    We capture subtle dynamic cues by taking the difference between consecutive feature maps. Grouped convolutions then extract motion features at a finer granularity, improving gaze estimation in scenarios with small but critical eye movements.

    \item \textbf{Multi-level recurrent fusion} (addresses L2).
    We progressively upsample deeper motion features and fuse them with shallower layers, unifying global and local context. This recurrent design ensures that the final representation retains both coarse and fine motion information.

    \item \textbf{PDA Loss for trajectory alignment} (addresses L3).
    We go beyond frame-by-frame supervision by introducing a sequence-level metric that aligns the predicted gaze trajectory (PoG) with the ground truth in both distance and angular shape. This ensures smoothness and reduces accumulated offset across frames.

    \item \textbf{Transformer-based temporal module} (addresses L4).
    To handle both short-term and longer-range dependencies, we replace traditional RNNs with a Transformer encoder, allowing parallel processing of the entire sequence. This improves efficiency and robustness, particularly when facing non-trivial head movements or extended gaze shifts.
\end{itemize}

Overall, by combining these components, RTDNet aims to resolve the above limitations and offer a more robust, accurate, and context-aware approach to video-based gaze estimation. The next chapter details each module in the proposed pipeline.

```
```
尽管许多研究已经尝试利用时间线索进行基于视频的凝视估计，但在这项工作中我们仍然致力于解决以下几个限制：

\begin{enumerate}[label=\textbf{L\arabic*:}, leftmargin=1.2cm]

\item \textbf{未明确建模帧间运动。}

大多数现有方法依赖于将帧堆叠到RNN（如LSTM、GRU）中，侧重于高级时间依赖性，但忽视了\emph{细粒度}的帧间变化。这些微妙的运动（如小的眼睛移动或部分面部运动）可以显著影响准确性，但标准的循环设计无法捕捉到这些细微变化。

\item \textbf{多级特征融合不足。}

循环或基于3D卷积的方法通常在单个阶段合并空间和时间特征。浅层可能捕捉到小细节但缺乏全局上下文，而深层则收集更广泛的上下文但错过了细微的运动线索。这种权衡通常会导致在出现大幅姿势变化或更微妙的眼动时性能不佳。

\item \textbf{轨迹级别的对齐被忽视。}

大多数方法独立计算逐帧损失（例如$\ell_2$或角度损失），从而忽略整个凝视轨迹的形状和连续性。即使连续帧被正确预测，轻微的逐帧偏移也会在时间上累积成不对齐或不平滑的轨迹。

\item \textbf{捕捉短期和长期依赖性具有挑战性。}

基于RNN的方法按顺序处理序列，这可能限制效率和学习长距离交互的能力。虽然一些作品采用双向方案或更深的LSTM堆栈，但处理扩展的视频片段或快速变化的凝视仍然具有挑战性，特别是在像头部旋转或部分遮挡这样的真实世界条件下。

\end{enumerate}

\vspace{0.5em}\noindent

\textbf{相应地，本论文提出了RTDNet，一种使用时间差异的循环网络，以解决这些问题：}

\begin{itemize}[leftmargin=1.2cm]

\item \textbf{用于明确帧间运动的TDModule}（解决L1）。

我们通过获取连续特征图之间的差异来捕捉微妙的动态线索。分组卷积然后以更细的粒度提取运动特征，改善了在存在小但关键眼动的情况下的凝视估计。

\item \textbf{多级循环融合}（解决L2）。

我们逐步上采样更深层的运动特征，并将它们与更浅的层融合，统一全局和局部上下文。这种循环设计确保最终表示保留粗糙和细微的运动信息。

\item \textbf{用于轨迹对齐的PDA Loss}（解决L3）。

我们通过引入一个序列级别的度量标准，将预测的凝视轨迹（PoG）与地面真相在距离和角度形状上对齐，超越
```

尽管之前的work尝试去利用时序信息来辅助video-based gaze estimation, 但仍有一些限制。
首先，它们没有显式建模帧间的运动信息，大多数方法依赖于将特征堆叠到RNN，侧重于时序信息的利用，但忽视了帧间的运动信息。眼球的微小运动以及面部肌肉的运动可以反应gaze的变化。
其次，gaze轨迹级别的对齐被忽视。大多数的方法独立计算逐帧的损失后累加，而忽视了整个gaze轨迹的形状和连续性。即使连续帧被正确预测，逐帧偏移也可能在时间上累计从而形成不对齐，不平滑的轨迹。
最后，捕捉短期和长期的帧间依赖具有挑战。基于RNN的方法按顺序处理序列，这可能限制长距离交互的能力。

关等人引入了MCGaze，捕获头部、面部和眼部区域之间的时空交互，从而改善视频凝视估计。



准确的凝视预测在不同领域中至关重要。许多工作致力于从静态图像中估计准确的凝视方向。最近，从视频中预测凝视方向引起了越来越多的关注，传统方法主要依赖于静态图像，这使得利用时间和运动信息变得具有挑战性。为了解决这个问题，我提出了RTDNet，这是一个使用时间差异的循环网络，用于视频凝视估计，它整合了帧间运动和时间序列信息以提高准确性。首先，我引入了时间差异模块（TDModule）来捕获帧间运动信息，以实现更好的凝视估计。它通过时间差分和分组卷积提取运动信息。然后，我将这些特征上采样，以创建更完整的运动表示，并通过循环结构将它们与原始视频特征在不同级别结合起来。我还使用Transformer来增强时间序列的处理。此外，我引入了点分布对齐损失（PDA Loss），通过使用序列信息来对凝视点（PoG）轨迹进行对齐，进一步提高准确性。我的方法在EVE和EYEDIAP数据集上实现了最先进的性能。我还建立了一个演示网站来展示我的工作。项目代码已发布在https://git.cs.bham.ac.uk/lxs432/rtdnet。



```
％！TEX根=../Dissertation.tex

\chapter{介绍}

人类凝视传达丰富的意图，在虚拟现实/增强现实等领域起着至关重要的作用\cite{gazevr1, gazevr2}，人机交互\cite{gazehci1, gazehci2}和安全监控\cite{gazesecurity1, ribeiro2019driver}。这个过程涉及大量的心理和动作相关信息的传递\cite{mele2012gaze}，使得研究准确的凝视估计方法非常有价值。

在深度学习方法广泛应用之前，许多凝视估计技术依赖于眼球的三维建模或测量电位差来确定凝视方向。然而，这些传统方法对个体差异非常敏感，需要昂贵的设备，使得大规模部署具有挑战性。

在计算机视觉领域，基于学习的凝视估计方法主要从外观图像中推断人类凝视方向\cite{cheng2024appearance, lei2023end}。这些方法使用网络摄像头捕获面部或眼部图像，并学习从外观到凝视方向的映射\cite{fullface, zhang2015appearance, park2018deep, cheng2020gaze, itracker, cheng2018appearance}。尽管这些方法因成本低廉和良好性能而受欢迎\cite{cheng2024appearance}，但它们主要局限于静态图像分析，并未充分考虑视频数据中的时间动态。

相比之下，视频由一系列连续帧组成，通过反映运动信息的帧间差异为凝视预测提供了有价值的补充数据\cite{wang2019neuro, bace2020combining, arnab2021vivit}。

运动信息描述了面部的运动，提供了丰富的微妙线索，为更准确的动态凝视估计提供了背景\cite{jindal2024spatio}。

此外，由于人类凝视遵循连续轨迹，周围帧中的凝视方向为当前帧的凝视估计提供了有价值的背景。

将视频中的时间动态背景和运动信息与现有的静态图像方法相结合，可能会对凝视预测产生积极影响\cite{cheng2024appearance}。

最近的视频凝视估计方法通常使用CNN架构作为骨干网络，从每帧中提取特征，并采用像LSTM这样的时间序列处理模块来整合多帧的特征，将这些特征映射到凝视方向\cite{kellnhofer2019gaze360, zhou2019learning, park2020towards}。

为了充分利用帧间运动信息和凝视点（PoG）序列分布信息，我提出了一种使用时间差异的循环网络进行视频凝视估计（RTDNet）。

首先，我定义了一个时间差异模块（TDModule）来提取帧间运动特征。该模块通过将视频特征应用于时间差分和分组卷积来捕获运动特征。接下来，我设计了一个循环网络架构，以不同层次整合运动信息和视频特征。具体来说，深层次的运动特征被上采样并与浅层次的运动特征结合，形成更

最近的视频凝视估计方法通常使用CNN架构作为骨干网络，从每一帧提取特征，并采用像LSTM这样的时间序列处理模块来整合多帧的特征，将这些特征映射到凝视方向。

为了充分利用帧间运动信息和凝视点序列分布信息，我提出了一种使用时间差异的循环网络进行视频凝视估计（RTDNet）。

首先，我定义了一个时间差异模块（TDModule）来提取帧间运动特征。该模块通过将视频特征与分组卷积相结合，应用时间差分来捕获运动特征。接下来，我设计了一个循环网络架构，以不同层次整合运动信息和视频特征。具体来说，深层运动特征被上采样并与浅层运动特征结合，形成更完整的运动表示。这种特征融合方法可以提高凝视的预测。然后，我重新提取视频特征并将完整的运动特征附加到它们上。此外，我比较了各种时间序列处理模块，并选择了Transformer作为进一步提高凝视预测准确性和有效性的方法。

此外，传统方法的损失函数通常在静态图像上评估估计准确性。对于视频中的凝视估计，大多数方法简单地聚合每帧的损失，而不考虑视频中的时间动态。我认为，使用凝视点序列中点的相对位置来衡量两条轨迹之间的差异将有助于模型的训练。因此，我提出了点分布对齐损失（PDA Loss），利用序列信息计算凝视点轨迹之间的差异，增强了预测和实际凝视轨迹之间的相似性，从而提高了凝视预测的准确性。

我的主要贡献总结如下：

- 我提出了一个从时间差异视频特征中提取帧间运动特征的时间差异模块（TDModule）。该模块捕获视频中的运动信息，提高了在凝视估计中运动信息的利用。

- 我设计了一个使用时间差异的循环网络进行视频凝视估计（RTDNet），通过利用TDModule和循环架构将运动信息整合到不同层次的视频特征中，并利用Transformer沿时间维度处理特征，最终将其映射到每帧的凝视方向。

- 我提出了点分布对齐损失（PDA Loss），从轨迹的角度对凝视点序列进行对齐，增强了视频凝视估计的准确性，使预测的凝视轨迹形状更接近于实际轨迹。

我的模型在EVE和EYEDIAP数据集上取得了最先进的性能。

此外，为了更直观地展示我的项目，我创建了一个专门的展示网页。该页面包括项目演示视频、交互式在线演示，以及模型训练曲线和实验结果的可视化。用户可以上传他们自己的视频进行模型推断，或使用EVE数据集进行测试。整个后端和前端服务器可以在配备GPU的消费级笔记本电脑上平稳运行。
```

```
在本章中，我将首先介绍凝视估计领域的发展及相关论文，随后阐述这些工作的局限性以及我从中获得的启发。

\section{非外观特征方法} 在深度学习成为凝视估计领域主流之前，传统的凝视估计方法主要依赖于眼球的三维建模或通过物理方式测量眼部电位来预测注视点\cite{guestrin2006general, hansen2009eye, lu2016estimating, alberto2014geometric, zhu2007novel}。然而，这些方法对个体差异非常敏感，难以在不同用户之间泛化，同时所需的设备往往较为昂贵\cite{cheng2024appearance}。因此，研究者逐渐将关注点转向基于外观的深度学习方法，该类方法通常以眼睛或人脸图像为输入。这些方法可进一步分为静态方法（使用单帧图像）和动态方法（处理视频序列）。在接下来的章节中，我将介绍这两类方法的相关研究。

\section{基于图像的凝视估计} 基于图像的凝视估计方法以相机拍摄的图像为输入，目标是从视觉特征中直接推断用户的注视方向。通常，卷积神经网络（CNN）被用作主干架构，因为其在图像特征提取方面具有很强的能力。早期，研究社区常以裁剪后的眼部图像作为输入。Zhang 等人\cite{zhang2015appearance}率先将 CNN 应用于该问题，使用 CNN 从灰度单目图像中提取特征，并结合头部姿态映射到注视向量。这项工作展示了深度学习方法在凝视估计中的可行性和潜力。

随后，Zhang 等人\cite{zhang2017mpiigaze}选择了更深的 CNN 模型 VGG16 作为主干网络，进一步提高了预测精度。Chen 等人\cite{chen2018appearance}采用了扩张卷积 CNN 来捕捉细微的眼部变化。Cheng 等人\cite{cheng2018fourstream}使用了四流 CNN 结合非对称回归方法，从双目图像中估计凝视方向，此设计在头部旋转或部分遮挡情况下提高了鲁棒性。

之后，一些研究开始使用整张人脸图像或人脸与眼睛的多图输入。人脸图像相比眼睛图像包含更多信息，如面部朝向和眼睛相对位置。Zhang 等人\cite{fullface}引入了空间加权机制以减少面部特征的噪声。Balim 等人\cite{balim2023efe}提出了一种类似 U-Net 的架构，直接从相机坐标系中预测六维凝视光线，绕过了复杂的预处理步骤。

除了基于 CNN 的方法，还有一些论文探索了基于 Transformer 的架构。Cheng 等人\cite{cheng2022gaze}将视觉 Transformer（ViT）与 CNN 结合，提高了精度。该设计结合了 Transformer 的全局上下文建模能力与 CNN 的强低级特征提取能力，在处理复杂头部姿态下的凝视偏移时尤为有效。

在查阅相关文献后，我最终选择了人脸图像作为模型输入，因为我认为面部特征提供的上下文信息有助于更准确地进行凝视预测。此外，我选择了广泛使用的 CNN 作为模型的特征提取主干网络。

\section{基于视频的凝视估计} 视频由连续帧组成，动态方法常利用时间信息来提升凝视估计的准确性。与静态图像相比，视频中的时间信息可以丰富凝视预测的上下文，并提升预测精度\cite{jindal2024spatio, park2020towards, zhou2019learning}。Palmero 等人\cite{palmero2018recurrent}提出了一种递归 CNN 架构，在特征提取后加入了循环模块，有效捕捉帧与帧之间的时间依赖关系，进而生成更准确的凝视方向预测。

Kellnhofer 等人\cite{kellnhofer2019gaze360}提出的 Gaze360 模型使用 pinball 双向 LSTM 处理 CNN 输出，不仅考虑当前帧，还结合了过去与未来帧的信息以优化当前帧的凝视估计，从而显著提高了预测的鲁棒性。然而，该方法存在一定缺陷：它虽然使用了多帧输入，但只输出中间帧的预测结果，限制了方法的效率。

Zhou 等人\cite{zhou2019learning}提出的改进版 Itracker 模型，先使用 CNN 从双眼和人脸中提取特征，再通过双向 LSTM 建模特征之间的时间依赖关系，实现了精确的凝视方向估计。这两篇论文都采用了双向 LSTM，因此我将在实验部分将其加入静态方法中，与我提出的方法进行对比。

Guan 等人\cite{guan2023end}提出了 MCGaze 模型，通过建模头部、面部和眼部区域的时空关系来提升凝视估计效果。

此外，也有研究引入了专为视频凝视估计构建的数据集，以推动该领域的发展。EYEDIAP 数据集\cite{funes2014eyediap}使用屏幕或漂浮物体作为目标，提供了丰富的注视目标和动态背景信息，适合验证视频凝视估计算法。EVE 数据集\cite{park2020towards}是一个大规模的视频凝视数据集，主要关注基于屏幕的凝视目标。研究者使用 GRU 处理图像特征，并结合屏幕内容的热图对初始预测进行细化，显著提高了预测精度。

以往处理时间信息的方法启发我们利用视频中包含的运动信息来提高凝视估计精度。我的方法在视频中提取帧间运动特征，并通过递归架构在不同层次上整合运动信息与视频特征，显式地利用运动信息以提高预测精度。

\section{现有方法的局限性} 尽管已有的视频凝视估计方法尝试利用时间信息提升精度，但仍存在一些挑战和局限：

首先，帧间运动信息没有被显式建模。大多数方法将特征堆叠后输入 RNN，虽考虑了时间信息，但忽略了帧间运动信息。眼球和头部的运动能够反映凝视变化趋势。Guan 等人\cite{guan2023end}发现，当头部移动而凝视方向与头部方向不一致时，预测误差将增加，这也说明显式建模运动信息的重要性。

其次，轨迹级对齐未被考虑。大多数方法是逐帧计算并累加损失，忽略了整个凝视轨迹的形状和连续性。即使单帧误差合理，轨迹仍可能未对齐。

第三，捕捉短期与长期帧间依赖仍然具有挑战性。基于 RNN 的模型按顺序处理序列，这限制了其效率与学习长期交互关系的能力。

\section{项目启发} 我希望提出一种新方法以提升凝视估计的精度。首先，我从前人的研究中汲取了一些经验。如第 2.2 节所述，CNN 和 ViT 均可作为主干网络，但考虑到计算资源限制，我选择 CNN 作为主干网络。对于输入，使用人脸图像的模型通常比使用眼部图像的模型效果更好，因此我将使用人脸图像作为输入。在数据集方面，目前该领域仅有的公开数据集是 EVE 数据集和 EYEDIAP 数据集，因此实验将在这两个数据集上进行。

同时，在第 2.4 节中我讨论了现有方法的局限性。为了解决这些问题，我获得了一些新的启发：

针对运动信息建模，我将在模型中显式加入一些上下文感知设计。CNN 主干的结构将被修改，使其具备捕捉运动信息的能力，从而丰富上下文信息。

针对轨迹级对齐问题，我将设计一种新的损失函数，该函数可在整个凝视轨迹上进行计算，而非仅计算单个预测结果。

针对时间序列建模，除了使用 RNN 外，我还将使用 Transformer，它已被广泛证明在处理序列问题上非常有效。

这些要素共同构成了我提出的 RTDNet 方法的基础，其具体细节将在第三章中详细介绍。
```

```
以下是你提供内容的中文翻译，保留了原始的 LaTeX 格式：

---

\chapter{方法论}

我提出了一种新型网络 RTDNet，通过学习帧间运动差异并对凝视分布进行对齐，实现视频中的凝视预测。首先，我将定义本任务以及后续章节中使用的符号。

本任务的目标是学习一个映射函数 $f: V \rightarrow G$，其中 $V \in \mathbb{R}^{T \times 3 \times H \times W}$ 表示输入的视频序列。这里，$T$ 表示视频的时间长度，$H$ 和 $W$ 分别表示每帧图像的高度和宽度。每帧是一个具有三个通道的 RGB 图像。输出 $G \in \mathbb{R}^{T \times 2}$ 表示所有帧的预测凝视方向，以俯仰角（pitch）和偏航角（yaw）表示。为实现这一目标，我提出了 RTDNet 网络。接下来的章节中，我将首先介绍用于捕捉连续帧间运动信息的 TDModule，其次介绍我们的循环架构设计。然后，我将介绍用于时间序列处理的 Transformer 模块。最后是 PDA Loss，它利用凝视点序列信息来度量两个轨迹之间的相似性。本章中所有的超参数设置将在第 4 章中详细说明。

\begin{figure*}[t] \centering \includegraphics[width=\textwidth]{rtdnet.png} \caption{\textbf{RTDNet 的架构。} RTDNet 以人脸视频作为输入，通过 ResBlock 提取视频特征，使用 TDModule 捕捉帧间运动信息，并将其附加到视频特征中。在第四层之后，深层运动特征会被上采样、卷积处理，并与浅层运动信息结合，获得完整的运动表征。最终通过循环结构将完整运动信息整合进视频特征，再送入 Transformer 在时间维度上处理特征，最终通过 MLP 映射输出每一帧的凝视方向。} \label{fig:ourmodel} \end{figure*}

	\section{网络结构} RTDNet 是一个使用时间差分（TD）机制的循环网络，用于视频凝视估计。RTDNet 以视频为输入，输出所有帧的凝视方向。它包含一个 TDModule 用于捕捉运动特征，以及一个循环架构，用于融合高层和低层特征以进行凝视估计。

\subsection{时间差分模块（TDModule）} 我设计了 TDModule 来从视频中提取运动特征。总体而言，TDModule 通过组卷积从时间差分特征中提取运动信息，从而提高凝视估计的准确性。

具体来说，TDModule 以视频特征作为输入，记为 F={ft∣t=0,1,…,T−1}F = \{f_t\mid t = 0, 1, \dots, T-1\} 。为了捕捉帧间的运动差异，我对提取出的视频特征图进行时间差分操作，得到差分特征集 ΔF={Δft∣Δft=ft+1−ft,t=0,1,…,T−2}\Delta F = \{\Delta f_t \mid \Delta f_t = f_{t+1} - f_t, t = 0, 1, \dots, T-2\}。

接下来，我们希望使用滑动窗口模块对多个差分特征进行聚合和分组，然后对每组应用卷积层以提取运动信息。为了使运动特征数量与帧数匹配，我对差分特征集进行零填充。具体来说，在序列 ΔF\Delta F 的开头填充 mm 个零，末尾填充 nn 个零，确保最终的组数为 TT。零填充滑动窗口聚合公式如下： \begin{equation} \widetilde{\Delta F} = {\underbrace{0, 0, \dots, 0}_{m \text{ 个零}}, \Delta f_0, \Delta f_1, \dots, \Delta f_{T-2}, \underbrace{0, 0, \dots, 0}_{n \text{ 个零}}}, \end{equation}

\begin{equation} \Delta F_{\text{win}}(w, s) = {\widetilde{\Delta F}_{i}^{(w)} \mid i = 0, 0+s, 0+2s, \dots}. \end{equation}

其中，ΔF~i(w)\widetilde{\Delta F}_{i}^{(w)} 表示从索引 ii 开始的 ww 个连续元素，前提是 i+w−1<len(ΔF~)i+w-1 < \text{len}(\widetilde{\Delta F})，ss 是滑动窗口的步长。


我提出了rtdnet以供视频凝视估算。它提取帧之间的时间差异特征，并采用经常性网络以不同级别集成这些功能，然后利用变压器进一步利用时间信息。我还提出了PDA损失，以更好地使预测的凝视轨迹与地面真相保持一致。



应用滑动窗口聚合后，我对每组应用卷积层以提取运动信息。分组操作还减少了差分特征的通道数，从而减少了卷积层的参数量。随后，我将提取出的运动特征加到原始视频特征上，得到融合了运动信息的视频特征，表示为：

\begin{equation} f^{'}_{t} = \text{Conv}\left(\widetilde{\Delta F}_{i}^{(w)}\right) + f_t. \end{equation}

我将这种运动特征提取方式称为 TDModule，其基本流程如图~\ref{fig:tdblock} 所示。

\begin{figure}[htbp] \centering \includegraphics[width=\linewidth]{tdblock.png} \caption{\textbf{TDModule 与短连接。} 首先计算时间差分特征，然后进行零填充，以确保卷积后的特征图数量与视频帧数一致。随后利用滑动窗口进行差分特征聚合，经过卷积后与原始特征相加。} \label{fig:tdblock} \end{figure}

\subsection{循环结构设计} 时间差分方法在多个领域被广泛用于捕捉运动信息。然而，将其应用于凝视估计面临独特挑战：眼部区域较小，面部动作较为细微。传统的特征融合方法难以有效地将运动信息与图像特征融合，导致预测性能不佳。为了解决这个问题，我提出了一种循环结构，对图像特征与运动信息进行多层次融合，提升凝视估计精度。如图~\ref{fig:ourmodel} 所示，网络将 TDModule 提取的运动特征与不同层次的视频特征进行整合。初步通过短连接进行特征融合，之后将深层运动特征上采样并与浅层特征结合，形成完整的运动表示，并通过循环结构融合至各层视频特征中。最终使用 Transformer 处理时间维度上的信息，并通过多层感知机（MLP）映射输出凝视方向。

具体而言，该网络以视频为输入。首先，我使用 ResBlock 提取每帧的特征，ResBlock 是 ResNet 中的基础残差块\cite{he2016deep}。随后使用 TDModule 提取运动信息，并与原始视频特征相加，将运动信息嵌入每帧特征中。对更深层的特征重复这一过程。

在第四层中，我去掉了短连接，保留 TDModule 提取的运动特征作为输出。随着网络加深，TDModule 可以捕捉到更全局的运动信息，但特征图的空间维度缩小，限制了细节运动的捕捉。相反，浅层特征保留了更多的细节信息，但缺乏上下文。为平衡全局与细节运动信息，我借鉴 Hourglass 网络的思想\cite{hourglass}，将深层特征图上采样并卷积降维，使其尺寸匹配上一层的特征，再相加补全运动信息。该过程层层递进，以增强每层的运动特征表达能力。

接着，我使用相同的 ResBlock 对视频特征重新提取，并与完整的运动特征拼接。在重复四次后，我得到了融合了丰富运动信息的视频特征。

如果直接将未上采样的特征送入 Transformer，最终效果与仅使用 ResNet-18 几乎相同，这也从侧面验证了多层次融合图像特征和运动特征的重要性。

接下来，考虑到人类注视持续不断地转移，视频连续帧中的注视方向对于预测当前帧的注视方向是一个重要的参考。因此，有必要引入一个模块来处理特征的时间变化。我选择使用Transformer编码器\cite{vaswani2017attention}来实现这一目的。

关于时间处理模块，我将在后面的一个单独章节中进行解释。

整个RTDNet过程写在算法~\ref{alg:rtdnet}中。

我还考虑了传统的时间处理模块，如RNN\cite{rumelhart1986learning}及其变种，GRU\cite{chung2014empirical}和LSTM\cite{hochreiter1997long}。这些方法之间的详细比较将在第~\ref{sec:tpm}节中讨论。

---

\section{时间处理模块（Temporal Process Module）} 为了有效处理帧间的时间信息，我引入了时间处理模块（Temporal Process Module）。尽管诸如 Transformer、RNN 以及其变体（如 LSTM 和 GRU）等架构被广泛用于处理时间动态问题，但本节主要讨论 Transformer 架构，因为它在处理序列数据中的长期依赖关系方面表现更为优越。

图~\ref{fig:ourmodel} 展示了我方法中使用的 Transformer 编码器架构。多头自注意力（Multi-Head Self-Attention, MSA）模块使模型能够并行处理输入序列的多个子空间。MSA 中的每个头独立计算注意力，从而增强模型捕捉多样化时间依赖关系的能力。该注意力机制的核心公式如下：

\begin{equation} \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V. \end{equation}

在该公式中，QQ、KK、VV 是由输入特征学习得到的查询、键和值矩阵，dkd_k 是键的维度。该公式展示了模型如何为序列中每个位置的特征动态分配权重，以判断其相对重要性。Transformer 能够在不同时间步之间关注到相关的信息，对于准确捕捉凝视行为的细节至关重要。

在视频凝视估计任务中，Transformer 架构具有以下几个显著优势。与逐步处理数据的 RNN 不同，Transformer 能够并行处理序列元素，从而大幅提升计算效率。更重要的是，Transformer 擅长捕捉全局时间依赖关系，能够更深入理解时间上的凝视模式。这一能力对于视频凝视估计尤为关键，因为凝视方向是连续变化的。准确建模这种连续变化需要同时考虑短期和长期的上下文因素，而 Transformer 正是在此方面表现卓越，从而提升了整个视频序列中的凝视预测精度。

\section{点分布对齐损失（Point Distribution Alignment Loss）}\label{sec:lossfunction} 本网络的损失函数由两部分组成：我提出的点分布对齐损失（PDA Loss）以及角度损失（Angular Loss）。角度损失从三维凝视向量计算，PDA Loss 从 PoG（注视点）序列计算。整体损失函数 $\mathcal{L}$ 表示如下：

\begin{equation} \mathcal{L} = \mathcal{L}_{angular} + \gamma\mathcal{L}_{PDA}. \end{equation}

其中 $\gamma$ 是用于平衡这两部分损失的系数。

\begin{figure}[t] \centering \includegraphics[width=0.8\linewidth]{pdaloss.png} \caption{\textbf{PDA Loss 的工作原理。} 点表示注视点 PoG，连线表示凝视轨迹。如图所示，PDA Loss 中的欧几里得距离项使得每个预测 PoG 更接近真实值。角度差 DD 度量了预测轨迹与真实轨迹之间的偏转角度差异。虽然 (a) 与 (b) 的欧几里得距离相同，但 (a) 的角度差 DD 更小，因此其轨迹形状更接近真实轨迹。这展示了 PDA Loss 如何通过最小化距离与角度差共同对齐预测轨迹。} \label{fig:pdaloss} \end{figure}

\subsection{PDA Loss} PDA Loss 用于计算两个凝视轨迹之间的差异。我通过计算凝视向量与屏幕的交点来获得注视点（PoG）。设 $P = (p_0, \dots, p_{T-1})$ 为预测的 PoG 序列，$Q = (q_0, \dots, q_{T-1})$ 为真实的 PoG 序列。

接下来，我计算序列中相邻点之间的方向向量：v⃗iP=pi+1−pi\vec{v}_i^P = p_{i+1} - p_i，v⃗iQ=qi+1−qi\vec{v}_i^Q = q_{i+1} - q_i。方向向量用于描述凝视轨迹的方向变化。

为了利用 PoG 序列信息，我进一步计算轨迹中每一段的角度变化差异。其中 θi\theta_i 表示真实轨迹中第 ii 段的角度差，θ^i\hat{\theta}_i 表示预测轨迹的对应角度差。其计算公式如下：

\begin{equation} \hat{\theta_i} = \arccos \left(\frac{\vec{v}_i^P \cdot \vec{v}_{i+1}^P}{|\vec{v}_i^P| |\vec{v}_{i+1}^P|)}\right), \end{equation}

在得到所有角度差之后，我定义一个新的指标 DD 来度量两条轨迹之间角度偏差的总和：

\begin{equation} D = \sum_{i=0}^{T-3}|\theta_i - \hat{\theta}_i|, \end{equation}

减小 DD 会使两条 PoG 轨迹更加平行，但若仅优化 DD，可能导致轨迹形状接近但位置偏移。为此，我引入欧几里得距离以确保每个 PoG 都与真实值对齐。最终，PDA Loss 定义如下：

\begin{equation} \mathcal{L}_{PDA}(P, Q) = \sum_{i=0}^{T-1}|p_i - q_i| + \lambda D. \end{equation}

其中 λ∈R>0\lambda \in \mathbb{R}_{>0} 是权重系数。总体而言，PDA Loss 同时最小化两序列对应点之间的距离，并通过角度偏差 DD 约束其相对位置关系。图~\ref{fig:pdaloss} 展示了 PDA Loss 的工作原理，它克服了仅使用欧几里得距离的局限，使预测轨迹在形状上更符合真实轨迹。这一过程加速了模型训练的收敛速度，同时也提升了最终的预测精度。

\subsection{角度损失（Angular Loss）} 角度损失用于在三维凝视向量维度上对预测结果进行对齐。设 TT 为视频帧序列长度，g^\mathbf{\hat{g}} 为预测的三维凝视向量，g\mathbf{g} 为真实凝视向量。Angular Loss 的计算公式为：

\begin{equation} \mathcal{L}_{\mathrm{angular}}\left(\mathbf{g}, \hat{\mathbf{g}}\right) = \frac{1}{T}\sum^{T} \frac{180}{\pi} \arccos\left(\frac{\mathbf{g} \cdot \hat{\mathbf{g}}}{|\mathbf{g}| |\hat{\mathbf{g}}|}\right). \end{equation}

该损失项通过计算预测与真实凝视向量之间的夹角，从而在方向维度对两者进行精确对齐，是凝视估计任务中的基础损失函数之一。

---

如需我帮你润色语言、优化逻辑、排版格式或生成完整论文模板，也可以继续告诉我！
```


```
% !TEX root =  ../Dissertation.tex

\chapter{实现细节}
本章节介绍本项目的实现细节，包括开发环境、数据预处理、模型构建与训练、推理过程以及演示网站。  
需要注意的是，本章侧重于代码结构与系统部署等实践层面的内容。关于网络架构、模块设计与损失函数的理论解释，请参考第三章。  
项目目录结构的简化版本如图 \ref{fig:stucture} 所示，接下来的小节将依次解释实现细节。

\begin{figure*}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{structure.png}
  \caption{本项目的结构}
  \label{fig:stucture}
\end{figure*}

\section{开发环境}
在开发环境方面，我使用搭载 NVIDIA 4090D 的服务器进行开发，系统为 Ubuntu 22.04 LTS。项目的主要部分使用 Python 3.11 开发。具体来说，深度学习部分使用 PyTorch 2.3 实现。在网页展示部分，我使用 FastAPI 0.115.5 作为后端框架，Vue 3 作为前端框架。项目所依赖的模块及其对应版本将在附录中列出。

\section{数据预处理}
在数据预处理方面，我采用了 Cheng 等人\cite{cheng2024appearance}推荐的数据预处理方法。具体来说，如果数据提供了面部关键点坐标以及相机坐标（训练阶段），我使用面部关键点的几何中心作为裁剪中心，然后以关键点间距的 1.5 倍为边长裁剪正方形区域作为面部区域，并将其缩放为 256x256。之后，为了消除由于相机距离和旋转造成的几何差异，我基于相机坐标构建旋转矩阵和缩放矩阵，使虚拟相机始终面向人脸中心并保持固定距离，以获得标准化图像。

如果数据未提供面部关键点坐标与相机坐标（推理阶段），我使用 Google 提供的 Mediapipe 机器学习库确定面部关键点坐标，以获取裁剪中心点，并通过将两眼之间距离固定为面部图像的 0.72 倍来近似标准化图像。

以上内容我均实现于 \texttt{datasource/eve\_sequences.py} 与 \texttt{eyediap\_sequences.py} 中。数据预处理与加载过程我封装成 dataloader，便于后续开发。

\section{模型构建与训练}
本项目的模型构建代码全部位于 \texttt{model/rtdnet.py} 中。训练与评估代码分别位于 \texttt{train.py}、\texttt{eval\_eve.py} 和 \texttt{eval\_eyediap.py} 中。

对于 EVE 和 EYEDIAP 两个数据集，输入视频序列 \( V \) 包含 30 帧图像，每帧通过对原始视频序列每隔三帧采样得到。每帧图像的尺寸为 \( 3 \times 256 \times 256 \)。

在 RTDNet 中，我使用 ResNet-18\cite{he2016deep} 残差块作为视频特征提取器。
对于滑动窗口模块，$w$ 和 $s$ 分别设为 5 和 1。
对于零填充，$m$ 和 $n$ 分别设为 2 和 3，意味着在序列前填充两个零特征图，在末尾填充三个。
上采样过程使用最近邻插值，位置嵌入设置为可学习参数。

在 Transformer 中，我采用了 8 头的多头注意力机制。
我仅使用单层 Transformer 编码器进行时间信息建模，输入维度为 512，前馈网络维度为 1024，dropout 率为 0.1，激活函数为 GeLU。

模型训练使用 Adam 优化器，权重衰减系数为 0.005。损失函数的超参数设置为 \( \gamma = 0.0005 \)、\( \lambda = 1 \)。损失函数的具体实现位于 \texttt{utils/loss.py} 中。

初始学习率在 EVE 数据集上设为 0.0005，在 EYEDIAP 数据集上设为 0.0001。在两个数据集上，我统一设定批大小为 16，训练最多进行 10 个 epoch。

我使用 wandb 对训练与测试过程中的日志进行可视化和管理，便于在线查看训练与测试状态。另外，我通过配置文件的方式管理超参数，相关文件位于 \texttt{core/config\_default.py}，使得我可以快速测试不同超参数。在训练过程中，每半个 epoch 会自动保存一次 checkpoint，所有参数存放于 \texttt{checkpoints} 目录下。

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{website.jpg} 
    \caption{\textbf{在线可视化网站} 本图展示了在线可视化网站的一些组件。} 
    \label{fig:website} 
\end{figure}

\section{推理过程}
在推理过程中，我首先使用 OBS（Open Broadcaster Software）录制用户视频，并使用上述数据预处理方法获取用户面部裁剪图像。然后使用训练好的模型对该视频进行推理。为保证内存使用合理，我将视频划分为多个 250 帧的片段进行分段推理。得到每帧的注视方向后，我使用 OpenCV 提供的箭头工具将注视方向向量在图像平面上的二维投影标记出来，并将所有帧重新组合为视频输出，从而获得可视化结果。

\section{演示网站}
在网页展示部分，我采用 FastAPI 作为后端框架，Vue 作为前端框架，遵循前后端分离和 RESTful API 的设计思想搭建网站。所有实验数据的可视化均通过前端模块 ECharts 实现。演示网站如图 \ref{fig:website} 所示。

```

```python
def preprocess(image, keypoints=None, camera=None, is_infer=False):
    if not is_infer and keypoints is not None and camera is not None:
        center = keypoints.mean(axis=0)
        size = 1.5 * np.linalg.norm(keypoints[0] - keypoints[1])
        crop = crop_face(image, center, size)
        crop = resize(crop, (256, 256))
        crop = standardize(crop, camera)  
    else:
        keypoints = detect_face_keypoints(image)  # MediaPipe
        center = keypoints.mean(axis=0)
        size = 1.5 * np.linalg.norm(keypoints[0] - keypoints[1])
        crop = crop_face(image, center, size)
        crop = resize(crop, (256, 256))
    return crop, center # center used for inference
```


```python
def draw_gaze_arrow_on_face(frames, center, pitch_yaw, arrow_length=200):
    output_frames = []
    for i in range(len(frames)):
        frame = frames[i].copy()
        pitch, yaw = pitch_yaw[i]
        dx = -arrow_length * np.cos(pitch) * np.sin(yaw)
        dy = -arrow_length * np.sin(pitch)
        h, w = frame.shape[:2]
        start = center
        end = (int(start[0] + dx), int(start[1] + dy))
        cv2.arrowedLine(frame, start, end, color=(0, 255, 0), thickness=2)
        output_frames.append(frame)
    return output_frames
```


```
% !TEX root =  ../Dissertation.tex

\chapter{实验与评估}

本章节将讨论 RTDNet 的实验设计和实验结果。

\section{数据集}
目前，唯一公开可用的、在实验室环境下采集的视频注视（gaze）数据集主要有 EVE 和 EYEDIAP。本文的实验即基于这两个数据集展开。

\subsection{EVE 数据集}
\textbf{EVE}\cite{park2020towards} 是一个包含超过 1200 万帧视频的注视数据集，来自于在受控实验室环境下采集的 54 名被试数据。该数据集提供了来自不同角度的 4 个同步摄像头视角，并包含多种视觉刺激，总共约 105 小时的视频数据。其官方标准数据集划分为 39 人作为训练集、5 人作为验证集，以及 10 人作为测试集。但由于测试集并未提供真实标签，为了保证模型评估的一致性，我在验证集上对所有模型进行评估。

\subsection{EYEDIAP 数据集}
\textbf{EYEDIAP}\cite{funes2014eyediap} 是一个专门为 RGB 和 RGB-D 方式进行视频注视估计算法评价而构建的数据集。该数据集包含了 16 名被试、94 次录制 session，涵盖了从头部姿态到视觉目标以及环境光照等多种变化。EYEDIAP 数据集包含静态和动态两种头部姿态，并且视觉目标分为三种类型：离散屏幕目标、连续屏幕目标以及 3D 悬浮球。为了进行模型的训练与评估，本文选取了连续屏幕目标的数据。

然而，EYEDIAP 官方并未提供标准的数据划分和预处理策略，因而不同方法间的公平对比较为困难。为解决该问题，我采用了 Cheng 等人在\cite{cheng2024appearance} 中提出的预处理与归一化方案，从而使评估更具可比性。此外，为了进一步提升评估的可靠性，我参考了 GazeHub\cite{cheng2024appearance} 中给出的数据划分策略，将数据分为四个子集进行 4 折交叉验证。同时，由于 PDA Loss 的计算依赖于头部相对于屏幕的相对位置，但 EYEDIAP 数据集中并没有为 3D 悬浮球的实验提供屏幕坐标，因此只使用屏幕目标的 session 进行实验。为了保证比较的公平性，对所有基线模型也做了相同的数据选择与处理。

\section{模型复杂度}
在输入网络之前，图像被统一缩放至 256×256 的分辨率，所有超参数均遵循上一章节所述的设置。最终训练完成的 RTDNet 模型包含约 1489 万个参数；作为对比，去掉 Transformer 模块的 ResNet-18 具有约 1169 万个参数，而更深的 ResNet-34 具有 2180 万个参数。这表明 RTDNet 在参数规模上处于适中水平，与常用的注视估计骨干网络相当，同时并未引入过高的模型复杂度与显存开销。

在标准 FP32 浮点精度推理时，RTDNet 的显存需求为 2.82 GB，足以在消费级 GPU 上完成部署。我还在 NVIDIA RTX 4090D 上对 30 帧的视频序列进行了推理时间测试，整段推理耗时约 0.03 秒，意味着模型具有极高的推理速度，可满足实时应用需求。此外，本模型的计算量约为每个序列 170 GFLOPs；因此，RTDNet 在维持高精度的同时也兼顾了较好的计算效率，适合在实时注视追踪场景下使用。


报告了地面真实值和预测值之间的平均角度误差。带有*标记的方法涉及校准或屏幕内容，使比较不太公平，但仍包括供参考。


\section{性能对比}
我选择了 EyeNet-GRU 变体\cite{park2020towards} 作为对比的基线模型，将其输入由眼部图像替换为面部图像，并使用 ResNet-18 作为骨干网络。在表 \ref{table:comparison} 的对比中，该模型被称为 FaceNet-GRU。此外，本文还对比了多种基于外观（appearance-based）的注视估计方法\cite{balim2023efe, fullface, zhang2017mpiigaze, cheng2022gaze, kellnhofer2019gaze360}。为确保公平性，我为其中一些静态方法额外添加了一个两层双向 LSTM 模块，或添加与 RTDNet 相同的 Transformer 模块，使其能利用视频的时序信息进行估计。表 \ref{table:comparison} 中有些方法\cite{park2020towards, bao2022individual} 借助标定或对 PoG 结果进行精调，因而取得了更低的误差；但其性能提升并非源于模型本身，因此仅在表中列出供参考。

相比于基线模型，RTDNet 在 EVE 数据集上的误差下降了 18.0\%，在 EYEDIAP 数据集上的误差下降了 4.0\%，达到了当前最佳性能。相较之下，在 EVE 数据集上获得的提升更为明显，主要归因于 EYEDIAP 数据集的人脸分辨率较低\cite{cheng2024appearance}。此外，与其他增强了时序信息的模型结果相一致，实验也表明对静态模型添加时序模块（如双向 LSTM 或 Transformer）有助于显著降低误差，从而印证了视频时序信息在注视估计任务中的重要性。进一步对比可知，以面部图像为输入的模型整体精度优于仅以眼部图像为输入的模型，这与已有研究结论相符\cite{cheng2024appearance}。由于 EFE\cite{balim2023efe} 并未公布具体代码或易于复现的细节，这里仅引用其报告中的结果以作参考。

\section{消融实验}
在本节中，我对 RTDNet 进行了消融实验，如表 \ref{table:combined} 所示，主要关注两个方面：1）去除网络的时序递归结构；2）去除 PDA Loss。所有实验均在 EVE 数据集上训练与测试，具体如下：

\noindent \textbf{w/o Recurrent Backbone and Transformer.}  
在这一设置中，我使用 ResNet-18 作为视频特征提取器，并用 GRU 进行时序处理，仅使用 Angular Loss 进行训练。这与表 \ref{table:comparison} 中的 FaceNet-GRU 模型一致，列出供对比参考。

\noindent \textbf{w/o Recurrent Backbone.}  
在这一设置中，我同样以 ResNet-18 作为视频特征提取器，并结合 Angular Loss 与 PDA Loss。RTDNet 之所以具有递归式的网络结构，原因在于它先由 TDModule 抽取运动特征，再通过上采样得到完整的运动表示，最后在不同网络层将这些运动特征与原始视频特征融合，从而提升注视预测的准确性。为了检验这一设计的有效性，我将递归网络替换为纯粹的 ResNet-18，然后将其特征直接送入 Transformer 进行时序处理。

\noindent \textbf{w/o PDA Loss.}  
PDA Loss 通过结合角度差与欧几里得距离，将 PoG 序列对齐到真实轨迹上，可以更好地利用视频中注视序列的分布信息。为评估其贡献，我在该设置中只使用 Angular Loss 训练 RTDNet，不包含 PDA Loss。

这个表格展示了循环架构和PDA损失对角度差异和普罗克鲁斯特距离的影响。


\subsection{角度结果}
表 \ref{table:combined} 展示了该消融实验的对比结果。相较于使用递归结构的模型，仅使用 ResNet-18 提取视频特征的模型在准确度上下降了约 20.5\%，这证明了递归式网络结构在挖掘运动信息方面的有效性。而当去除 PDA Loss 时，模型的性能相较于同时使用 PDA Loss 的情况下降了 3.0\%。这表明在注视序列的分布对齐层面上，PDA Loss 进一步提高了预测精度。

\subsection{序列相似度结果}
为进一步分析 PDA Loss 对 PoG 序列对齐的影响，我对比了使用和不使用 PDA Loss 训练的模型在 EVE 数据集上的注视点序列（PoG）预测表现。虽然在实际推理阶段并不需要计算 PoG（因缺少 gaze origin），但这里为了考察 PDA Loss 对序列对齐的效果，仍额外提供了视线起始点坐标。采用了 Procrustes 距离\cite{gower1975generalized} 作为衡量相似度的指标，该方法在进行平移、旋转和缩放对齐后，计算两序列的差异度。表 \ref{table:combined} 的结果显示，启用 PDA Loss 后 PoG 序列的平均 Procrustes 距离可降低 5.2\%，因此 PDA Loss 在约束轨迹形状、平滑注视运动并提升空间预测精度方面具有有效性。

\section{时序模块替换实验}\label{sec:tpm}
在本节中，我探讨了在相同的注视估计框架下，替换不同的时序处理模块所带来的影响。为公平起见，所有模型均在 EVE 数据集中进行训练和测试。对 RNN 及其变体（如 GRU、LSTM），输入与隐藏层维度均设置为 512，与骨干网络输出一致。实验结果显示，Transformer 结构在所有时序模块中取得了最优表现。与 RNN 系列相比，Transformer 能更好地建模视频中长程依赖和复杂的时序模式，对注视估计这种连续且易受多因素影响的预测任务尤其有益。因此，Transformer 成为了本文最终模型中用于时序处理的最优选择。

\section{定性评估}
我通过可视化展示模型的注视预测结果进行定性分析，如图 \ref{fig:visualgaze} 所示。可以看到，RTDNet 能在多种具有挑战性的情况下保持较高的预测准确度：\emph{（1）快速注视转移时，}模型仍能稳定地跟踪注视方向，充分利用了运动信息来确保预测的注视轨迹与真实值对齐；\emph{（2）面部被手部动作部分遮挡时，}模型依然能够做出可靠预测，体现了通过融合时序和运动特征所带来的鲁棒性；\emph{（3）在光照条件较差的环境下，}模型依然能保持较好的预测性能，展示了其对于复杂或不利环境的适应能力。

另外，为了进一步说明 PDA Loss 的贡献，我在图 \ref{fig:pdatj} 中可视化了开启和关闭 PDA Loss 时在屏幕上的 PoG 轨迹。结果显示，启用 PDA Loss 的模型不仅在轨迹形状上更加接近真实值，在与真实注视点间的欧几里得距离上也更小，从而直观地验证了 PDA Loss 在约束注视轨迹形状、平滑注视运动以及增强空间预测准确度等方面的有效性。

```

这幅图展示了模型性能的可视化。蓝色箭头代表\textcolor{blue}{\textbf{预测凝视方向}}，而红色箭头表示\textcolor{red}{\textbf{真实值}}。每个框架的左上角标有凝视的俯仰角和偏航角。箭头描绘了在2D图像中凝视方向的投影，因此它们的长度并不重要。每行对应不同的视频。

这幅图描述了屏幕上一个人的凝视轨迹，通过连接凝视点完成。图中的橙色线代表\textcolor{orange}{\textbf{地面真相}}，蓝色线代表\textcolor{blue}{\textbf{使用PDA Loss模型的预测结果}}，绿色代表\textcolor[RGB]{0,128,0}{\textbf{不使用PDA Loss的模型预测结果}}。每幅图的左上角分别标注了p1和p2，表示使用和不使用PDA Loss的Procrustes距离。坐标的单位是像素，屏幕分辨率为1920 $\times$ 1080。

```
% !TEX root =  ../Dissertation.tex

\chapter{法律、社会、伦理及专业相关问题}

本项目使用了深度学习技术来完成视频注视估计任务。在开发过程中，涉及了多方面的法律、社会、伦理及专业问题。以下将对这些问题进行详细讨论。

\section{法律与伦理问题}

我使用了 EVE 数据集\cite{park2020towards} 和 EYEDIAP 数据集\cite{funes2014eyediap} 来训练并测试模型。这两个数据集中都涉及到了数据隐私和版权的问题。

EVE 数据集由苏黎世联邦理工学院（ETH Zurich）发布，遵循 CC BY-NC-SA 4.0 协议，即只能用于非商业研究。本项目也遵循了这一要求。EVE 还符合 GDPR（欧盟《通用数据保护条例》）的相关原则：访问数据集需要使用教育机构邮箱；如果任何参与者要求删除其数据，ETH Zurich 会通知所有已获得数据的用户（包括本项目）删除相应部分数据。本项目将严格遵守这些要求。

EYEDIAP 数据集由 Idiap 研究所于 2014 年发布，也需要使用教育邮箱来获取。由于 GDPR 于 2018 年才出台，EYEDIAP 并未在文档中明确说明对 GDPR 的合规性。然而，据其文档描述，所有参与者在录制前都被告知了相关流程，并且数据中并未包含任何敏感信息。

\section{社会问题}

就社会层面而言，主要会关注公平性、技术滥用以及社会接纳度等问题。在公平性方面，EVE 和 EYEDIAP 数据集本身即是相对公平的数据集，涵盖了来自不同族裔背景的参与者，也包含佩戴眼镜的用户。我的测试结果显示，模型在有无眼镜的群体间都能够保持一致的表现。

关于潜在的技术滥用，EVE 数据集的 CC BY-NC-SA 4.0 协议严格限制其只可用于非商业研究，同样适用于本项目，能在一定程度上减少技术滥用的风险。

至于社会接纳度，注视估计技术已在自动驾驶、VR/AR 等领域展现出价值。只要在实际应用中对数据使用的目的和范围进行清晰的告知，就能增强公众的信任与认可。

\section{专业问题}

在开源方面，本项目将采用 GPL 协议，希望借此鼓励更多后续研究与社区贡献。同时，为遵循 EVE 数据集的 CC BY-NC-SA 4.0 协议，我不会公开训练所得的模型参数文件或任何数据集内容，以避免违反其非商业使用限制。

在专业行为方面，我遵循了 BCS（英国计算机学会）对从业者的行为准则，其中包括尊重隐私、诚实地报告研究结果，以及对公众和专业团体负责。通过发布我的代码，我希望展现研究的透明度与可复现性，从而促进研究的诚信，支持后续的学术交流与改进。
 th
```

```
% !TEX root =  ../Dissertation.tex

\chapter{项目管理}
该项目于 2024 年 6 月启动，历时约五个月。我采用了迭代式的开发方法，并根据每个阶段得到的实验结果，不断对模型设计、实验和评估进行调整。项目的进度安排如图 \ref{fig:timeline} 所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\linewidth]{timeline.png} 
    \caption{本项目的时间线} 
    \label{fig:timeline} 
\end{figure}

项目主要的里程碑如下：

\begin{itemize}[itemsep=0pt, parsep=0pt, topsep=0pt]

    \item \textbf{选题阶段（2024 年 6 月 - 2024 年 6 月）}

    在项目初期，我与导师进行了多次讨论，结合研究兴趣及技术热点，最终确定了基于视频的注视估计作为本项目的研究方向。

    \item \textbf{基线模型实现（2024 年 6 月 - 2024 年 8 月）}

    在确定研究方向后，我阅读了导师推荐的论文，并实现了几种在该任务上的基准模型。为了保证评估的公平性和一致性，我还研究了多个开源实现，搭建了统一的评测框架。

    \item \textbf{模型设计（2024 年 8 月 - 2024 年 9 月）}

    在对领域基础有了初步理解后，我进一步阅读了更多文献，并提出了五种候选模型结构。对每个候选结构进行了测试和分析，并在与导师的进一步讨论后确定了最终的模型设计。为了提高模型的可解释性，我还绘制了网络结构图并尝试对模型进行解释，期间也得到了导师的反馈。

    \item \textbf{超参数设置（2024 年 9 月 - 2024 年 9 月）}

    确定模型结构后，我进行了网格搜索（grid search），以寻找能够取得最佳性能的超参数组合。

    \item \textbf{实验（2024 年 9 月 - 2024 年 11 月）}

    为了增强实验结果的可信度，我复现了多种最新的先进模型，与我的模型进行对比分析。同时，我也进行了消融实验，以量化各个模块对最终性能的贡献。  
    此外，为了衡量不同注视轨迹的相似度，我引入了 Procrost 距离作为新的度量指标。

    \item \textbf{报告撰写（2024 年 12 月 - 2025 年 1 月）}

    在最终阶段，我完成了本项目的报告撰写。  
    为了更好地展示项目，我开发了一个示例网站，用于演示研究背景、技术方法、关键结果以及可视化展示，帮助读者快速理解本研究的主要贡献。
\end{itemize}

```

```
在这个项目中，我解决了以往视频凝视估计方法的局限性，这些方法没有充分利用视频中的运动和时间信息。我提出了一种使用时间差异的循环网络进行视频凝视估计（RTDNet），以及其关键组件——时间差异模块（TDModule）和PDA Loss函数。TDModule通过时间差分和分组卷积从视频特征中提取运动信息。随后，我通过上采样创建了更完整的运动特征表示，并通过循环过程在不同层次上融合这些运动特征和视频特征。我使用Transformer处理时间信息。PDA Loss利用视频序列信息对凝视点轨迹进行对齐，提高了预测准确性。RTDNet在EVE和EYEDIAP数据集上实现了最先进的性能。我开发了一个在线可视化网站，让用户可以访问我的模型进行推断，并推广我的工作。

未来的工作可以在以下几个方面展开。首先，设计更有效的方法来捕获和整合运动信息，以更好地利用上下文信息来增强视频凝视估计结果。其次，将这种方法扩展到多人凝视估计场景，将推动现实生活的边界。第三，创建一个新的基于视频的凝视估计数据集，因为在这个领域仍然缺乏数据集。%%  %%
```

上述实验结果说明了RTDNet在video gaze estimation领域达到了一个较好的性能，通过对视频中的空间与时间信息的显式利用改善了估计精度，PDA Loss也让gaze trajectory在形状和连续性上与ground truth更加相近。然而，本工作仍存在一些limitations。在本节我们将讨论这些limitations以及future work方向
根据已有的实验数据，可以看到本工作有一些主观和客观层面的limitations。
低分辨率下优势不显著。在EYEDIAP数据集上并未体现出显著的优势，相比静态方法只好一点。说明方法对于图像分辨率以及注视原点坐标的依赖。
使用Transformer之后训练时间较长。尽管Transformer在推理速度以及性能上较好，但在30帧的数据上，在batch size设置为16，epoch为10的情况下需训练11小时，而在使用RNN时只需训练8小时。
数据多样性不足。受制于缺乏公开数据集，目前只在EVE与EYEDIAP上做了验证。
未在不受控以及多人场景实验。本项目专注于受控的实验室环境实验，并未测试不受控以及多人场景。

未来工作
根据以上limitations，未来工作可以在以下几个方面展开
探索本框架在低分辨率场景下的应用。在低分辨率下捕捉运动信息是个挑战
尝试使用更高效的Temporal processing model, 利用更高效的结构如FlashAttention，Mamba来替换传统的Transformer Encoder。
收集video gaze estimation相关数据集
尝试将方法迁移到未受控环境


```
.
├── README.md
├── api
│   ├── main.py
│   ├── videos
│   └── vue-dist
├── continue_train.py
├── core
│   ├── config_default.py
│   ├── tensorboard.py
│   └── training.py
├── datasources
│   ├── EyediapTest.py
│   ├── common.py
│   └── eve_sequences.py
├── eval.py
├── eval_eyediap.py
├── infer_for_eve.py
├── infer_for_normal.py
├── model
│   ├── eyenet.py
│   ├── eyenet_frame.py
│   └── facenet_transformer.py
├── requirements.txt
├── saving
├── train.py
├── utils
│   ├── loss.py
│   ├── mask.py
│   ├── util_functions.py
│   └── wandb_setup.py
└── wandb
```


课程没有规定实体的数量，我只是说，去年平均每个人分配到大概2-3个实体，具体组内如何分配其实没有明确规定。我认为，如果你的实体只被你自己需要而不是组内其他人，那么你需要考虑一下你实体的定义是否合理。我们在M2中就已经规定了compile jdl file together去合并你们的entity

We don't have a strict rule on the number of entities. It is only for reference that on average each student was responsible for about 2-3 entities last year, and the specific division of labor can be flexibly negotiated within the group.

From my personal perspective, I think 9 entities are not very common. If each of them plays a necessary role in fulfilling your task, you’re free to keep them. In Jhipster, the concept of an _entity_ isn't exactly the same as a Java class or a database table. If you only store it as an object without corresponding webpages/APIs, then your design is likely to be over-complication, as we mentioned in M1. If the entity is not used by any team members other than yourself, you might consider merging it into a larger entity. Overemphasizing strict database normalization can lead to redundant design.

You might also want to consider whether some of the entities can be merged with those of your teammates, or replaced by simpler structures like enums.

最后再强调一下，这只是我个人的看法，使用9个entities肯定能完成任务，只是不太优雅。如果你已经没时间考虑再次设计架构，那么就保留你自己的设计，尽快完成项目。祝你好运。

We don't have a strict rule on the number of entities. It is only for reference that on average each student was responsible for about 2-3 entities last year, and the specific division of labor can be flexibly negotiated within the group.

From my personal perspective, I think 9 entities are not very common. If each of them plays a necessary role in fulfilling your task, you’re free to keep them. In Jhipster, the concept of an entity isn't exactly the same as a Java class or a database table. If you only store it as an object without corresponding webpages/APIs, then your design is likely to be over-complication, as we mentioned in M1. If the entity is not used by any team members other than yourself, you might consider merging it into a larger entity. Overemphasizing strict database normalization can lead to redundant design.

Just to reiterate, everything above is just my personal opinion — using 9 entities will certainly get the job done, though it might not be the most elegant solution. If you no longer have time to revisit the architecture, then it's perfectly fine to stick with your current design and focus on finishing the project. Best of luck!

纸质档：1、论文装订一本、2、材料册里包含任务书（2+2交开题报告）、调研报告、译文（2+2翻译调研报告）、成绩评定表装订成一本，如国外还有其他相关的材料也可一并装进去；纸质档的封面需用中南大学的论文专用封面。  以上都需要将电子材料拷贝给曾老师，论文上传至格子达，并查重；


我的学位项目是BSc of Computer Science。目前，使用人工智能方法解决实际问题是计算机科学研究方向的一大热点，而我的项目是使用深度学习方法中的一个分支：计算机视觉方法解决gaze estimation的问题，以便在视线追踪，自动驾驶等领域应用，所以我的final year project与我的学位program相关性极强。

此外，为了便于用户的使用与体验，我还将开发展示网站，以便用户上传自己的视频来进行video gaze estimation。网站开发与api设计涉及到web开发与软件工程的知识，是计算机科学应用的传统领域，更加证明了我项目与学位项目的相关性。

My degree program is BSc of Computer Science. Nowadays, using artificial intelligence to solve real-world problems is a major research hotspot in the domain of computer science. My final year project aims to use a branch technique of deep learning: computer vision technique to addresses the video-based gaze estimation problem. This is relevant to some useful fields like gaze tracking and autonomous driving. Therefore, my algorithm design of my final year project is highly related to my degree program.

Besides, to make my algorithm accessible to normal users, I plan to develop a demonstration website that allow users to upload their own videos for video gaze estimation inference. The development of the webpage and API design involves knowledges of web developing and software engineering knowledge, which are traditional areas of computer science. This further proves the close relationship between my project and my degree program.


人类的凝视传达了丰富的意图，并在许多领域中发挥着关键作用，如虚拟现实/增强现实（VR/AR）\cite{gazevr1, gazevr2}、人机交互\cite{gazehci1, gazehci2}和安全监控\cite{gazesecurity1, ribeiro2019driver}。这个过程涉及心理和与行动相关的信息传递\cite{mele2012gaze}，使得凝视估计的研究具有很高的价值。

在深度学习方法广泛应用于该领域之前，许多凝视估计方法依赖于3D眼球重建或测量眼睛之间的电位差。然而，这些传统方法需要在不同个体之间重新校准，而且设备昂贵，不适合大规模部署。

在计算机视觉领域，基于学习的凝视估计方法主要分析人类外观图像来获得凝视方向\cite{cheng2024appearance, lei2023end}。这些方法需要使用网络摄像头捕捉面部或眼部图像，并学习从图像到凝视方向的映射\cite{fullface, zhang2015appearance, park2018deep, cheng2020gaze, itracker, cheng2018appearance}。虽然这些方法因其低成本和良好的性能而广受欢迎，但大多数方法仅限于静态图像分析。这些静态方法已经达到了性能的瓶颈，因为它们无法利用时间和运动信息，从而限制了它们在视频场景中的潜力。

视频是由一系列连续的帧组成，帧间差异可以反映运动信息，为视频凝视估计提供一些有用的附加信息\cite{wang2019neuro, bace2020combining, arnab2021vivit}。运动信息描述了面部运动，为更准确的动态凝视估计提供了一些微妙但丰富的线索\cite{jindal2024spatio}。此外，由于人类的凝视遵循连续的轨迹，周围帧中的凝视方向提供了有价值的背景信息。将时间信息和运动信息与静态凝视估计方法结合，可以对视频凝视估计产生积极的效果\cite{cheng2024appearance}。





人类的凝视传达了丰富的意图，并在许多领域中发挥着关键作用，如虚拟现实/增强现实（VR/AR）\cite{gazevr1, gazevr2}、人机交互\cite{gazehci1, gazehci2}和安全监控\cite{gazesecurity1, ribeiro2019driver}。这个过程涉及心理和与行动相关的信息传递\cite{mele2012gaze}，使得凝视估计的研究具有很高的价值。

然而，在深度学习方法广泛应用于本领域，凝视估计方法大多依赖3D眼球重建或测量眼睛之间的电位差，需要在不同个体之间重新校准，而且设备昂贵，不适合大规模部署。在计算机视觉领域，基于学习的凝视估计方法主要分析人类外观图像来获得凝视方向\cite{cheng2024appearance, lei2023end}。这些方法需要使用网络摄像头捕捉面部或眼部图像，并学习从图像到凝视方向的映射\cite{fullface, zhang2015appearance, park2018deep, cheng2020gaze, itracker, cheng2018appearance}。然而，这些方法大多局限在静态图像分析，达到了性能的瓶颈。

考虑到视频是由一系列连续的帧组成，帧间差异可以反映运动信息\cite{wang2019neuro, bace2020combining, arnab2021vivit, jindal2024spatio}，本项目将尝试提出一个新的video-based gaze estimation模型，修改CNN骨干以能够利用motion information。此外，本项目将利用Transformer\cite{vaswani2017attention}来model temporal information。本网络将被命名为RTDNet。另外，考虑到大多方法只是在单独的PoG上进行对齐\cite{kellnhofer2019gaze360, zhou2019learning, park2020towards, jindal2024spatio}。为了利用PoG的序列信息来对齐gaze轨道，我将提出一个可以利用点分布信息的PDA Loss。

为了直观展示我的项目，我创建了一个可视化演示网站。它包含了项目演示视频、互动演示、模型训练曲线和实验结果的可视化。用户可以上传自己的视频并使用预训练的模型推断凝视方向，或者使用EVE数据集进行测试。



封面
摘要
intro（项目概述）
文献综述（背景） 
技术基础
- 深度学习
  本项目采用了基于深度学习的计算机视觉方法进行video-based gaze estimation。深度学习是机器学习的一个分支，通过加深神经网络的层次从而使得网络能够学习数据的模式，自动从数据中提取出对应特征并做出决策。
  在本项目中，我们将涉及到卷积神经网络，循环神经网络，Transformer以及基于Transformer的一些方法。除了网络结构，深度学习还涉及到损失函数的设计，我们也会在下面介绍。
- CNN
	- CNN作为backbone
	  卷积神经网络由LeCun等人提出，通过一系列的卷积操作提取图像中的特征，卷积操作的数学表示为：【公式】
	  这样的操作能够处理图像中的局部依赖关系。从深度学习技术流行之后，人们提出了如VGG，ResNet等网络来加深CNN网络从而达到更好的效果，在本项目中我将会采用ResNet。
	- ResNet的使用
	  本项目中采用了ResNet为骨干的CNN网络作为了视频特征提取器。Residual Networks通过引入skip connection解决了深度卷积神经网络训练中梯度消失的问题，让网络能够变得更深从而达到更好的效果。ResNet-18是本项目将会采用的ResNet变种。原理如图【图】
- RNN
  RNN及其变种通过隐藏状态来存储先前时间步的信息，从而能够处理时间序列数据。传统的RNN的数学表示为：【公式】
  然而，Vanilla RNN在时间序列较长时很难建模长时间的特征依赖关系。于是，x等人提出了LSTM通过门控机制来使得梯度可以正常反向传递，从而减少了梯度爆炸或梯度消失的风险。x等人提出的GRU通过简化LSTM的门控结构减少了计算复杂度。三种RNN的基本单元如图所示【图】
  在本项目中，RNN主要被用于作为时序处理模块与Transformer进行对比，从而体现不同时序处理模块的性能差距。
- Transformer
	- Transformer由xx提出，在许多NLP任务中证明了自己的有效性。在本项目中，我将采用Transformer Encoder作为时序处理模块来建模不同帧之间gaze方向的依赖关系。Transformer使用了多头自注意力机制，使用多次映射的Q，K，V矩阵来捕捉复杂的依赖关系。其中，注意力机制的计算公式为【公式】
	- Transformer在spatio-temporal两个层次上都可以很好的捕捉依赖关系。spt et al将Transformer利用到了pose estimation任务中，在空间和时间两个维度上使用Transformer捕捉依赖关系，从而得到优秀的实验结果。这也启发我们使用这样的关系来处理运动和时序关系。
- VIT
  除了CNN可以作为video feature extractor，cheng等人也利用ViT来作为backbone来进行gaze estimation。ViT将图像划分为多个patches，将其作为序列输入到Transformer进行处理。其优势在于可以全局建模图像特征，而不是像CNN一样依赖局部卷积操作。Cheng等人的工作也得到了很好的gaze estimation结果。然而，由于本项目计算资源有限，而ViT的开销较大，所以我们将不对这种方法进行试验。
- 损失函数
  Loss Function作为深度学习训练中的一环，也十分重要。在gaze estimation任务中，人们通常使用两种Loss Function：L1 Loss以及Angular Loss。我将在下文介绍它们。
	- L1
	  L1 Loss通过计算预测gaze directio以及ground truth之间的绝对差来度量误差，其对异常值不敏感，在一些任务中鲁棒性较好。其公式为【公式】
	- Angular Loss
	  Angular Loss 用于将预测的3D凝视向量与地面真实值对齐。这里，\(T\) 是视频的长度。首先，我们将预测的凝视向量 \(\mathbf{\hat{g}}\) 和地面真实值凝视向量 \(\mathbf{g}\) 转换为3D格式，角度损失定义如下：
	  与简单的L1 Loss相比，角度损失为球面方向误差提供了更有意义的几何级别指标。它计算向量之间的角度差异，并在方向级别上对齐两个向量。这种损失函数在凝视估计任务中被广泛使用。
- web
	- 基于python，调研Django，Fastapi等
	  深度学习模型通常使用Python下的Pytorch框架开发，这使得基于python的后端框架成为第一选择，比如FastAPI，DJango等。他们可以直接调用pytorch实现的推理函数，而不需要复杂的进程间通信。本项目采用了FastAPI作为后端框架。它是一个高性能的web框架，相比Django，FastAPI具有更好的性能以及异步编程支持，尤其适用于深度学习模型的在线推理任务。它可以与pytorch模型集成，进行实时的推理和结果返回。
	- 前端Vue
	  Vue是由youyuxi团队开源的渐进式前端框架，本框架的特点是通过component模版将html，css，js封装在同一文件中，从而将前段开发的任务拆卸成为组建开发，增强了项目管理能力以及可服用行。本项目将会采用Vue来开发演示网站的前端页面。
实验方案
- 架构简要介绍
- 数据集
- 预处理
- 指标
  3Dgaze向量的角度偏差将会作为一个评测metric。其可以表示为：【公式】
	- 度数
	- 普世距离
- 模型复杂度
模型的复杂度是衡量模型有效性的重要指标。在模型训练成功后，我将会分析其参数量，内存占用，推理时间，并计算FLOPS数。
- 对比试验
- 消融实验
- 时间模块对比试验
- 可视化实验
	- Gaze estimation用于预测用户的gaze方向，可用三维向量在用户照片平面上的二维投影来可视化用户的gaze轨迹。此外，借助数据集中的gaze origin坐标，可以将用户gaze向量与屏幕平面相交得到PoG从而得到用户在屏幕上的gaze轨迹。我将采取上述两种方法将结果可视化。
- 用户上传视频
	- 网站的主要功能是供用户上传视频，使用预训练的模型进行推理，并可视化gaze方向。我将部署网站，供用户上传自己的视频进行推理，从而测试webpage是否正常工作。
结论与未来工作


准确的凝视估计在不同领域中至关重要。有许多研究从静态图片中估计准确的凝视方向。最近，从视频中估计凝视方向越来越受到关注。传统方法主要依赖于静态图片，这使得利用时间和运动信息变得具有挑战性。为了解决问题，我首先review了现有的工作，并介绍了常用的gaze estimation技术，拟定了一个名为RTDNet，一种使用时间差异的循环网络，来解决目前video gaze estimation的问题。它利用TDModule去提取运动信息，用循环结构做多层次的运动信息融合，用Transformer去捕捉时序依赖关系，从而得到更好的估计结果。我还将提出PDA Loss，在轨迹角度对齐两个PoG序列。另外，结合现有工作，我为本项目的实验部分做出了规划，以全面测试我提出的算法。最后，我对过往方法的缺点进行了分析，提出了未来工作的方向，以促进gaze estimation社区的发展。

在本调研报告中，我首先介绍了gaze estimation 方向并介绍了video gaze estimation这一任务的特殊性。我review了多篇前人的工作，并选出了一些共性技术进行了介绍。根据这些工作的一些缺陷，我提出了RTDNet，一个xxxx。它通过利用运动信息增强视频特征，并通过Transformer建模时序依赖。它还利用了PDA Loss来做轨迹层次的对齐。结合前人的工作，我提出了一份详细的实验计划。我还分析了前人工作的不足，并给出了一些可能的外来工作方向。
综上，本课题依据充分，在理论和实验层面都具备了可行性，对gaze estimation社区以及相关应用领域有重要意义。

预期贡献
你还没实验呢，分店里买呢把实验结果改了。



```
#"[0" \* MERGEFORMAT
#"0]" \* MERGEFORMAT
```


曾老师，很抱歉在五一期间打扰您，但现在的问题是，格子达系统里面我没有课题（选题），所以我现在没法上传格子达系统。您看我这个该怎么处理一下呢
![](assets/Pasted%20image%2020250502213523.webp)
曾老师您好，非常抱歉在五一假期打扰您！由于我目前在英国，我们之间有时差，我先将问题发给您，您在方便时回复即可。我的问题具体是：
1. 我曾收到消息说我需要提交毕业大论文以及任务书（2+2交开题报告）、调研报告、译文（2+2翻译调研报告）。这些材料我已经准备好了，但对于格式方面我有些不确定。因为在英国，我的论文都是使用LaTeX编写的，并且只能导出为PDF格式，而不是Word文件。我想询问是否可以在保持格式和模版不变的情况下，只将封面更换为中南大学的封面？由于我将于5月10号至30号参加英国的考试，时间较为紧张，如果可以不做其他修改，我希望能保持现有格式不变，我预估改模版的工作量是很大的。
2. 您曾提到需要在格子达系统上提交我的论文查重。然而，我在格子达系统中的“我的课题”一栏为空（如图一）。我认为这比较正常，因为我并没有参与选题过程。但随之而来的问题是，我尝试通过左侧的“答辩前论文 -> 提交论文” 这一栏提交论文时，系统提示“您还没有课题”（如图二）。这似乎意味着我如果没有课题的话就不能在格子达系统上交论文。这似乎意味着如果没有课题，我就无法在格子达系统上提交论文。考虑到我后续需要在该系统上传论文，烦请您帮忙查看并指导如何解决此问题。
3. 论文提交是否有一个具体时限？我询问英国这边，他们说在六月下旬会出毕业论文的成绩单，这就意味着我就有相当于国内要求的“成绩评定表”了。如果能在这个时间提交，我正好也考完试了，时间也相对松一点。
提前感谢曾老师的回复，麻烦您了！
   ![](assets/Pasted%20image%2020250502221203.webp)![](assets/Pasted%20image%2020250502221229.webp)
Hi Arthur,
Sorry for the late reply. I'm not in the UK now so I didn't check my inbox these days. Don’t be too hard on yourself, many of us feel the same pressure. To be honest, from my personal standpoint I don’t think the course is optimally structured. In class we were never really taught how to build a front‑end/back‑end‑separated web‑application demo, and much of our time was consumed by tasks like environment setup. I’ve already raised these concerns with the school this year; the course will be revamped next year, potentially merging with the Software Engineering module.
Regarding your question, I can give you these suggestions:
1.First do the most critical function. Make the prescription filtering available, the front-end interface only needs to be free of obvious bugs, and beautification can be done last.
2.Try to have an emergency in-person meeting within the team, preferably with everyone present, to inquire about how to complete their own parts. Web development is relatively cumbersome, but each part is not too difficult. A 2-hour offline meeting is enough for people within the group to help you understand how to develop. Don't be shy, directly @ the person you think can help you solve the problem in the group chat.
Seize the remaining time, wish you good luck!
Linli Shi



老实说，从我个人角度，我认为这一课程的安排并不完全合理，在课上你们并没有被教授如何开发如何开发一个前后端分离的web应用demo，很多时间也被浪费在了一些诸如环境配置的事情上。今年我已向学校反映，明年这门课将会被改革，或与软件工程课合并。